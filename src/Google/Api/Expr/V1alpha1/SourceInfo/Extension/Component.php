<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: google/api/expr/v1alpha1/syntax.proto

namespace Google\Api\Expr\V1alpha1\SourceInfo\Extension;

use UnexpectedValueException;

/**
 * CEL component specifier.
 *
 * Protobuf type <code>google.api.expr.v1alpha1.SourceInfo.Extension.Component</code>
 */
class Component
{
    /**
     * Unspecified, default.
     *
     * Generated from protobuf enum <code>COMPONENT_UNSPECIFIED = 0;</code>
     */
    const COMPONENT_UNSPECIFIED = 0;
    /**
     * Parser. Converts a CEL string to an AST.
     *
     * Generated from protobuf enum <code>COMPONENT_PARSER = 1;</code>
     */
    const COMPONENT_PARSER = 1;
    /**
     * Type checker. Checks that references in an AST are defined and types
     * agree.
     *
     * Generated from protobuf enum <code>COMPONENT_TYPE_CHECKER = 2;</code>
     */
    const COMPONENT_TYPE_CHECKER = 2;
    /**
     * Runtime. Evaluates a parsed and optionally checked CEL AST against a
     * context.
     *
     * Generated from protobuf enum <code>COMPONENT_RUNTIME = 3;</code>
     */
    const COMPONENT_RUNTIME = 3;

    private static $valueToName = [
        self::COMPONENT_UNSPECIFIED => 'COMPONENT_UNSPECIFIED',
        self::COMPONENT_PARSER => 'COMPONENT_PARSER',
        self::COMPONENT_TYPE_CHECKER => 'COMPONENT_TYPE_CHECKER',
        self::COMPONENT_RUNTIME => 'COMPONENT_RUNTIME',
    ];

    public static function name($value)
    {
        if (!isset(self::$valueToName[$value])) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no name defined for value %s', __CLASS__, $value));
        }
        return self::$valueToName[$value];
    }


    public static function value($name)
    {
        $const = __CLASS__ . '::' . strtoupper($name);
        if (!defined($const)) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no value defined for name %s', __CLASS__, $name));
        }
        return constant($const);
    }
}

