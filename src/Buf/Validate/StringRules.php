<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: buf/validate/validate.proto

namespace Buf\Validate;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * StringRules describes the constraints applied to `string` values These
 * rules may also be applied to the `google.protobuf.StringValue` Well-Known-Type.
 *
 * Generated from protobuf message <code>buf.validate.StringRules</code>
 */
class StringRules extends \Google\Protobuf\Internal\Message
{
    /**
     *`const` requires the field value to exactly match the specified value. If
     *the field value doesn't match, an error message is generated.
     *```proto
     *message MyString {
     *  // value must equal `hello`
     *   string value = 1 [(buf.validate.field).string.const = "hello"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string const = 1 [json_name = "const", (.buf.validate.priv.field) = {</code>
     */
    protected $const = null;
    /**
     *`len` dictates that the field value must have the specified
     *number of characters (Unicode code points), which may differ from the number
     *of bytes in the string. If the field value does not meet the specified
     *length, an error message will be generated.
     *```proto
     *message MyString {
     *  // value length must be 5 characters
     *   string value = 1 [(buf.validate.field).string.len = 5];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 len = 19 [json_name = "len", (.buf.validate.priv.field) = {</code>
     */
    protected $len = null;
    /**
     *`min_len` specifies that the field value must have at least the specified
     *number of characters (Unicode code points), which may differ from the number
     *of bytes in the string. If the field value contains fewer characters, an error
     *message will be generated.
     *```proto
     *message MyString {
     *  // value length must be at least 3 characters
     *   string value = 1 [(buf.validate.field).string.min_len = 3];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {</code>
     */
    protected $min_len = null;
    /**
     *`max_len` specifies that the field value must have no more than the specified
     *number of characters (Unicode code points), which may differ from the
     *number of bytes in the string. If the field value contains more characters,
     *an error message will be generated.
     *```proto
     *message MyString {
     *  // value length must be at most 10 characters
     *   string value = 1 [(buf.validate.field).string.max_len = 10];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {</code>
     */
    protected $max_len = null;
    /**
     *`len_bytes` dictates that the field value must have the specified number of
     *bytes. If the field value does not match the specified length in bytes,
     *an error message will be generated.
     *```proto
     *message MyString {
     *  // value length must be 6 bytes
     *   string value = 1 [(buf.validate.field).string.len_bytes = 6];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.priv.field) = {</code>
     */
    protected $len_bytes = null;
    /**
     *`min_bytes` specifies that the field value must have at least the specified
     *number of bytes. If the field value contains fewer bytes, an error message
     *will be generated.
     *```proto
     *message MyString {
     *  // value length must be at least 4 bytes
     *   string value = 1 [(buf.validate.field).string.min_bytes = 4];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.priv.field) = {</code>
     */
    protected $min_bytes = null;
    /**
     *`max_bytes` specifies that the field value must have no more than the
     *specified number of bytes. If the field value contains more bytes, an
     *error message will be generated.
     *```proto
     *message MyString {
     *  // value length must be at most 8 bytes
     *   string value = 1 [(buf.validate.field).string.max_bytes = 8];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.priv.field) = {</code>
     */
    protected $max_bytes = null;
    /**
     *`pattern` specifies that the field value must match the specified
     *regular expression (RE2 syntax), with the expression provided without any
     *delimiters. If the field value doesn't match the regular expression, an
     *error message will be generated.
     *```proto
     *message MyString {
     *  // value does not match regex pattern `^[a-zA-Z]//$`
     *   string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string pattern = 6 [json_name = "pattern", (.buf.validate.priv.field) = {</code>
     */
    protected $pattern = null;
    /**
     *`prefix` specifies that the field value must have the
     *specified substring at the beginning of the string. If the field value
     *doesn't start with the specified prefix, an error message will be
     *generated.
     *```proto
     *message MyString {
     *  // value does not have prefix `pre`
     *   string value = 1 [(buf.validate.field).string.prefix = "pre"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string prefix = 7 [json_name = "prefix", (.buf.validate.priv.field) = {</code>
     */
    protected $prefix = null;
    /**
     *`suffix` specifies that the field value must have the
     *specified substring at the end of the string. If the field value doesn't
     *end with the specified suffix, an error message will be generated.
     *```proto
     *message MyString {
     *  // value does not have suffix `post`
     *   string value = 1 [(buf.validate.field).string.suffix = "post"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string suffix = 8 [json_name = "suffix", (.buf.validate.priv.field) = {</code>
     */
    protected $suffix = null;
    /**
     *`contains` specifies that the field value must have the
     *specified substring anywhere in the string. If the field value doesn't
     *contain the specified substring, an error message will be generated.
     *```proto
     *message MyString {
     *  // value does not contain substring `inside`.
     *   string value = 1 [(buf.validate.field).string.contains = "inside"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string contains = 9 [json_name = "contains", (.buf.validate.priv.field) = {</code>
     */
    protected $contains = null;
    /**
     *`not_contains` specifies that the field value must not have the
     *specified substring anywhere in the string. If the field value contains
     *the specified substring, an error message will be generated.
     *```proto
     *message MyString {
     *  // value contains substring `inside`.
     *   string value = 1 [(buf.validate.field).string.not_contains = "inside"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string not_contains = 23 [json_name = "notContains", (.buf.validate.priv.field) = {</code>
     */
    protected $not_contains = null;
    /**
     *`in` specifies that the field value must be equal to one of the specified
     *values. If the field value isn't one of the specified values, an error
     *message will be generated.
     *```proto
     *message MyString {
     *  // value must be in list ["apple", "banana"]
     *  repeated string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
     *}
     *```
     *
     * Generated from protobuf field <code>repeated string in = 10 [json_name = "in", (.buf.validate.priv.field) = {</code>
     */
    private $in;
    /**
     *`not_in` specifies that the field value cannot be equal to any
     *of the specified values. If the field value is one of the specified values,
     *an error message will be generated.
     *```proto
     *message MyString {
     *  // value must not be in list ["orange", "grape"]
     *  repeated string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
     *}
     *```
     *
     * Generated from protobuf field <code>repeated string not_in = 11 [json_name = "notIn", (.buf.validate.priv.field) = {</code>
     */
    private $not_in;
    /**
     *This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
     *enable strict header validation. By default, this is true, and HTTP header
     *validations are [RFC-compliant](https://tools.ietf.org/html/rfc7230#section-3). Setting to false will enable looser
     *validations that only disallow `\r\n\0` characters, which can be used to
     *bypass header matching rules.
     *```proto
     *message MyString {
     *   // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
     *   string value = 1 [(buf.validate.field).string.strict = false];
     *}
     *```
     *
     * Generated from protobuf field <code>optional bool strict = 25 [json_name = "strict"];</code>
     */
    protected $strict = null;
    protected $well_known;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $const
     *          `const` requires the field value to exactly match the specified value. If
     *          the field value doesn't match, an error message is generated.
     *          ```proto
     *          message MyString {
     *            // value must equal `hello`
     *             string value = 1 [(buf.validate.field).string.const = "hello"];
     *          }
     *          ```
     *     @type int|string $len
     *          `len` dictates that the field value must have the specified
     *          number of characters (Unicode code points), which may differ from the number
     *          of bytes in the string. If the field value does not meet the specified
     *          length, an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value length must be 5 characters
     *             string value = 1 [(buf.validate.field).string.len = 5];
     *          }
     *          ```
     *     @type int|string $min_len
     *          `min_len` specifies that the field value must have at least the specified
     *          number of characters (Unicode code points), which may differ from the number
     *          of bytes in the string. If the field value contains fewer characters, an error
     *          message will be generated.
     *          ```proto
     *          message MyString {
     *            // value length must be at least 3 characters
     *             string value = 1 [(buf.validate.field).string.min_len = 3];
     *          }
     *          ```
     *     @type int|string $max_len
     *          `max_len` specifies that the field value must have no more than the specified
     *          number of characters (Unicode code points), which may differ from the
     *          number of bytes in the string. If the field value contains more characters,
     *          an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value length must be at most 10 characters
     *             string value = 1 [(buf.validate.field).string.max_len = 10];
     *          }
     *          ```
     *     @type int|string $len_bytes
     *          `len_bytes` dictates that the field value must have the specified number of
     *          bytes. If the field value does not match the specified length in bytes,
     *          an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value length must be 6 bytes
     *             string value = 1 [(buf.validate.field).string.len_bytes = 6];
     *          }
     *          ```
     *     @type int|string $min_bytes
     *          `min_bytes` specifies that the field value must have at least the specified
     *          number of bytes. If the field value contains fewer bytes, an error message
     *          will be generated.
     *          ```proto
     *          message MyString {
     *            // value length must be at least 4 bytes
     *             string value = 1 [(buf.validate.field).string.min_bytes = 4];
     *          }
     *          ```
     *     @type int|string $max_bytes
     *          `max_bytes` specifies that the field value must have no more than the
     *          specified number of bytes. If the field value contains more bytes, an
     *          error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value length must be at most 8 bytes
     *             string value = 1 [(buf.validate.field).string.max_bytes = 8];
     *          }
     *          ```
     *     @type string $pattern
     *          `pattern` specifies that the field value must match the specified
     *          regular expression (RE2 syntax), with the expression provided without any
     *          delimiters. If the field value doesn't match the regular expression, an
     *          error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value does not match regex pattern `^[a-zA-Z]//$`
     *             string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
     *          }
     *          ```
     *     @type string $prefix
     *          `prefix` specifies that the field value must have the
     *          specified substring at the beginning of the string. If the field value
     *          doesn't start with the specified prefix, an error message will be
     *          generated.
     *          ```proto
     *          message MyString {
     *            // value does not have prefix `pre`
     *             string value = 1 [(buf.validate.field).string.prefix = "pre"];
     *          }
     *          ```
     *     @type string $suffix
     *          `suffix` specifies that the field value must have the
     *          specified substring at the end of the string. If the field value doesn't
     *          end with the specified suffix, an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value does not have suffix `post`
     *             string value = 1 [(buf.validate.field).string.suffix = "post"];
     *          }
     *          ```
     *     @type string $contains
     *          `contains` specifies that the field value must have the
     *          specified substring anywhere in the string. If the field value doesn't
     *          contain the specified substring, an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value does not contain substring `inside`.
     *             string value = 1 [(buf.validate.field).string.contains = "inside"];
     *          }
     *          ```
     *     @type string $not_contains
     *          `not_contains` specifies that the field value must not have the
     *          specified substring anywhere in the string. If the field value contains
     *          the specified substring, an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value contains substring `inside`.
     *             string value = 1 [(buf.validate.field).string.not_contains = "inside"];
     *          }
     *          ```
     *     @type array<string>|\Google\Protobuf\Internal\RepeatedField $in
     *          `in` specifies that the field value must be equal to one of the specified
     *          values. If the field value isn't one of the specified values, an error
     *          message will be generated.
     *          ```proto
     *          message MyString {
     *            // value must be in list ["apple", "banana"]
     *            repeated string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
     *          }
     *          ```
     *     @type array<string>|\Google\Protobuf\Internal\RepeatedField $not_in
     *          `not_in` specifies that the field value cannot be equal to any
     *          of the specified values. If the field value is one of the specified values,
     *          an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value must not be in list ["orange", "grape"]
     *            repeated string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
     *          }
     *          ```
     *     @type bool $email
     *          `email` specifies that the field value must be a valid email address
     *          (addr-spec only) as defined by [RFC 5322](https://tools.ietf.org/html/rfc5322#section-3.4.1).
     *          If the field value isn't a valid email address, an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value must be a valid email address
     *             string value = 1 [(buf.validate.field).string.email = true];
     *          }
     *          ```
     *     @type bool $hostname
     *          `hostname` specifies that the field value must be a valid
     *          hostname as defined by [RFC 1034](https://tools.ietf.org/html/rfc1034#section-3.5). This constraint doesn't support
     *          internationalized domain names (IDNs). If the field value isn't a
     *          valid hostname, an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value must be a valid hostname
     *             string value = 1 [(buf.validate.field).string.hostname = true];
     *          }
     *          ```
     *     @type bool $ip
     *          `ip` specifies that the field value must be a valid IP
     *          (v4 or v6) address, without surrounding square brackets for IPv6 addresses.
     *          If the field value isn't a valid IP address, an error message will be
     *          generated.
     *          ```proto
     *          message MyString {
     *            // value must be a valid IP address
     *             string value = 1 [(buf.validate.field).string.ip = true];
     *          }
     *          ```
     *     @type bool $ipv4
     *          `ipv4` specifies that the field value must be a valid IPv4
     *          address. If the field value isn't a valid IPv4 address, an error message
     *          will be generated.
     *          ```proto
     *          message MyString {
     *            // value must be a valid IPv4 address
     *             string value = 1 [(buf.validate.field).string.ipv4 = true];
     *          }
     *          ```
     *     @type bool $ipv6
     *          `ipv6` specifies that the field value must be a valid
     *          IPv6 address, without surrounding square brackets. If the field value is
     *          not a valid IPv6 address, an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value must be a valid IPv6 address
     *             string value = 1 [(buf.validate.field).string.ipv6 = true];
     *          }
     *          ```
     *     @type bool $uri
     *          `uri` specifies that the field value must be a valid,
     *          absolute URI as defined by [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3). If the field value isn't a valid,
     *          absolute URI, an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value must be a valid URI
     *             string value = 1 [(buf.validate.field).string.uri = true];
     *          }
     *          ```
     *     @type bool $uri_ref
     *          `uri_ref` specifies that the field value must be a valid URI
     *          as defined by [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) and may be either relative or absolute. If the
     *          field value isn't a valid URI, an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value must be a valid URI
     *             string value = 1 [(buf.validate.field).string.uri_ref = true];
     *          }
     *          ```
     *     @type bool $address
     *          `address` specifies that the field value must be either a valid hostname
     *          as defined by [RFC 1034](https://tools.ietf.org/html/rfc1034#section-3.5)
     *          (which doesn't support internationalized domain names or IDNs) or a valid
     *          IP (v4 or v6). If the field value isn't a valid hostname or IP, an error
     *          message will be generated.
     *          ```proto
     *          message MyString {
     *            // value must be a valid hostname, or ip address
     *             string value = 1 [(buf.validate.field).string.address = true];
     *          }
     *          ```
     *     @type bool $uuid
     *          `uuid` specifies that the field value must be a valid UUID as defined by
     *          [RFC 4122](https://tools.ietf.org/html/rfc4122#section-4.1.2). If the
     *          field value isn't a valid UUID, an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value must be a valid UUID
     *             string value = 1 [(buf.validate.field).string.uuid = true];
     *          }
     *          ```
     *     @type int $well_known_regex
     *          `well_known_regex` specifies a common well-known pattern
     *          defined as a regex. If the field value doesn't match the well-known
     *          regex, an error message will be generated.
     *          ```proto
     *          message MyString {
     *            // value must be a valid HTTP header value
     *             string value = 1 [(buf.validate.field).string.well_known_regex = 2];
     *          }
     *          ```
     *          #### KnownRegex
     *          `well_known_regex` contains some well-known patterns.
     *          | Name                          | Number | Description                               |
     *          |-------------------------------|--------|-------------------------------------------|
     *          | KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |
     *          | KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2)  |
     *          | KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2.4) |
     *     @type bool $strict
     *          This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
     *          enable strict header validation. By default, this is true, and HTTP header
     *          validations are [RFC-compliant](https://tools.ietf.org/html/rfc7230#section-3). Setting to false will enable looser
     *          validations that only disallow `\r\n\0` characters, which can be used to
     *          bypass header matching rules.
     *          ```proto
     *          message MyString {
     *             // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
     *             string value = 1 [(buf.validate.field).string.strict = false];
     *          }
     *          ```
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Buf\Validate\Validate::initOnce();
        parent::__construct($data);
    }

    /**
     *`const` requires the field value to exactly match the specified value. If
     *the field value doesn't match, an error message is generated.
     *```proto
     *message MyString {
     *  // value must equal `hello`
     *   string value = 1 [(buf.validate.field).string.const = "hello"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string const = 1 [json_name = "const", (.buf.validate.priv.field) = {</code>
     * @return string
     */
    public function getConst()
    {
        return isset($this->const) ? $this->const : '';
    }

    public function hasConst()
    {
        return isset($this->const);
    }

    public function clearConst()
    {
        unset($this->const);
    }

    /**
     *`const` requires the field value to exactly match the specified value. If
     *the field value doesn't match, an error message is generated.
     *```proto
     *message MyString {
     *  // value must equal `hello`
     *   string value = 1 [(buf.validate.field).string.const = "hello"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string const = 1 [json_name = "const", (.buf.validate.priv.field) = {</code>
     * @param string $var
     * @return $this
     */
    public function setConst($var)
    {
        GPBUtil::checkString($var, True);
        $this->const = $var;

        return $this;
    }

    /**
     *`len` dictates that the field value must have the specified
     *number of characters (Unicode code points), which may differ from the number
     *of bytes in the string. If the field value does not meet the specified
     *length, an error message will be generated.
     *```proto
     *message MyString {
     *  // value length must be 5 characters
     *   string value = 1 [(buf.validate.field).string.len = 5];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 len = 19 [json_name = "len", (.buf.validate.priv.field) = {</code>
     * @return int|string
     */
    public function getLen()
    {
        return isset($this->len) ? $this->len : 0;
    }

    public function hasLen()
    {
        return isset($this->len);
    }

    public function clearLen()
    {
        unset($this->len);
    }

    /**
     *`len` dictates that the field value must have the specified
     *number of characters (Unicode code points), which may differ from the number
     *of bytes in the string. If the field value does not meet the specified
     *length, an error message will be generated.
     *```proto
     *message MyString {
     *  // value length must be 5 characters
     *   string value = 1 [(buf.validate.field).string.len = 5];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 len = 19 [json_name = "len", (.buf.validate.priv.field) = {</code>
     * @param int|string $var
     * @return $this
     */
    public function setLen($var)
    {
        GPBUtil::checkUint64($var);
        $this->len = $var;

        return $this;
    }

    /**
     *`min_len` specifies that the field value must have at least the specified
     *number of characters (Unicode code points), which may differ from the number
     *of bytes in the string. If the field value contains fewer characters, an error
     *message will be generated.
     *```proto
     *message MyString {
     *  // value length must be at least 3 characters
     *   string value = 1 [(buf.validate.field).string.min_len = 3];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {</code>
     * @return int|string
     */
    public function getMinLen()
    {
        return isset($this->min_len) ? $this->min_len : 0;
    }

    public function hasMinLen()
    {
        return isset($this->min_len);
    }

    public function clearMinLen()
    {
        unset($this->min_len);
    }

    /**
     *`min_len` specifies that the field value must have at least the specified
     *number of characters (Unicode code points), which may differ from the number
     *of bytes in the string. If the field value contains fewer characters, an error
     *message will be generated.
     *```proto
     *message MyString {
     *  // value length must be at least 3 characters
     *   string value = 1 [(buf.validate.field).string.min_len = 3];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {</code>
     * @param int|string $var
     * @return $this
     */
    public function setMinLen($var)
    {
        GPBUtil::checkUint64($var);
        $this->min_len = $var;

        return $this;
    }

    /**
     *`max_len` specifies that the field value must have no more than the specified
     *number of characters (Unicode code points), which may differ from the
     *number of bytes in the string. If the field value contains more characters,
     *an error message will be generated.
     *```proto
     *message MyString {
     *  // value length must be at most 10 characters
     *   string value = 1 [(buf.validate.field).string.max_len = 10];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {</code>
     * @return int|string
     */
    public function getMaxLen()
    {
        return isset($this->max_len) ? $this->max_len : 0;
    }

    public function hasMaxLen()
    {
        return isset($this->max_len);
    }

    public function clearMaxLen()
    {
        unset($this->max_len);
    }

    /**
     *`max_len` specifies that the field value must have no more than the specified
     *number of characters (Unicode code points), which may differ from the
     *number of bytes in the string. If the field value contains more characters,
     *an error message will be generated.
     *```proto
     *message MyString {
     *  // value length must be at most 10 characters
     *   string value = 1 [(buf.validate.field).string.max_len = 10];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {</code>
     * @param int|string $var
     * @return $this
     */
    public function setMaxLen($var)
    {
        GPBUtil::checkUint64($var);
        $this->max_len = $var;

        return $this;
    }

    /**
     *`len_bytes` dictates that the field value must have the specified number of
     *bytes. If the field value does not match the specified length in bytes,
     *an error message will be generated.
     *```proto
     *message MyString {
     *  // value length must be 6 bytes
     *   string value = 1 [(buf.validate.field).string.len_bytes = 6];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.priv.field) = {</code>
     * @return int|string
     */
    public function getLenBytes()
    {
        return isset($this->len_bytes) ? $this->len_bytes : 0;
    }

    public function hasLenBytes()
    {
        return isset($this->len_bytes);
    }

    public function clearLenBytes()
    {
        unset($this->len_bytes);
    }

    /**
     *`len_bytes` dictates that the field value must have the specified number of
     *bytes. If the field value does not match the specified length in bytes,
     *an error message will be generated.
     *```proto
     *message MyString {
     *  // value length must be 6 bytes
     *   string value = 1 [(buf.validate.field).string.len_bytes = 6];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.priv.field) = {</code>
     * @param int|string $var
     * @return $this
     */
    public function setLenBytes($var)
    {
        GPBUtil::checkUint64($var);
        $this->len_bytes = $var;

        return $this;
    }

    /**
     *`min_bytes` specifies that the field value must have at least the specified
     *number of bytes. If the field value contains fewer bytes, an error message
     *will be generated.
     *```proto
     *message MyString {
     *  // value length must be at least 4 bytes
     *   string value = 1 [(buf.validate.field).string.min_bytes = 4];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.priv.field) = {</code>
     * @return int|string
     */
    public function getMinBytes()
    {
        return isset($this->min_bytes) ? $this->min_bytes : 0;
    }

    public function hasMinBytes()
    {
        return isset($this->min_bytes);
    }

    public function clearMinBytes()
    {
        unset($this->min_bytes);
    }

    /**
     *`min_bytes` specifies that the field value must have at least the specified
     *number of bytes. If the field value contains fewer bytes, an error message
     *will be generated.
     *```proto
     *message MyString {
     *  // value length must be at least 4 bytes
     *   string value = 1 [(buf.validate.field).string.min_bytes = 4];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.priv.field) = {</code>
     * @param int|string $var
     * @return $this
     */
    public function setMinBytes($var)
    {
        GPBUtil::checkUint64($var);
        $this->min_bytes = $var;

        return $this;
    }

    /**
     *`max_bytes` specifies that the field value must have no more than the
     *specified number of bytes. If the field value contains more bytes, an
     *error message will be generated.
     *```proto
     *message MyString {
     *  // value length must be at most 8 bytes
     *   string value = 1 [(buf.validate.field).string.max_bytes = 8];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.priv.field) = {</code>
     * @return int|string
     */
    public function getMaxBytes()
    {
        return isset($this->max_bytes) ? $this->max_bytes : 0;
    }

    public function hasMaxBytes()
    {
        return isset($this->max_bytes);
    }

    public function clearMaxBytes()
    {
        unset($this->max_bytes);
    }

    /**
     *`max_bytes` specifies that the field value must have no more than the
     *specified number of bytes. If the field value contains more bytes, an
     *error message will be generated.
     *```proto
     *message MyString {
     *  // value length must be at most 8 bytes
     *   string value = 1 [(buf.validate.field).string.max_bytes = 8];
     *}
     *```
     *
     * Generated from protobuf field <code>optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.priv.field) = {</code>
     * @param int|string $var
     * @return $this
     */
    public function setMaxBytes($var)
    {
        GPBUtil::checkUint64($var);
        $this->max_bytes = $var;

        return $this;
    }

    /**
     *`pattern` specifies that the field value must match the specified
     *regular expression (RE2 syntax), with the expression provided without any
     *delimiters. If the field value doesn't match the regular expression, an
     *error message will be generated.
     *```proto
     *message MyString {
     *  // value does not match regex pattern `^[a-zA-Z]//$`
     *   string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string pattern = 6 [json_name = "pattern", (.buf.validate.priv.field) = {</code>
     * @return string
     */
    public function getPattern()
    {
        return isset($this->pattern) ? $this->pattern : '';
    }

    public function hasPattern()
    {
        return isset($this->pattern);
    }

    public function clearPattern()
    {
        unset($this->pattern);
    }

    /**
     *`pattern` specifies that the field value must match the specified
     *regular expression (RE2 syntax), with the expression provided without any
     *delimiters. If the field value doesn't match the regular expression, an
     *error message will be generated.
     *```proto
     *message MyString {
     *  // value does not match regex pattern `^[a-zA-Z]//$`
     *   string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string pattern = 6 [json_name = "pattern", (.buf.validate.priv.field) = {</code>
     * @param string $var
     * @return $this
     */
    public function setPattern($var)
    {
        GPBUtil::checkString($var, True);
        $this->pattern = $var;

        return $this;
    }

    /**
     *`prefix` specifies that the field value must have the
     *specified substring at the beginning of the string. If the field value
     *doesn't start with the specified prefix, an error message will be
     *generated.
     *```proto
     *message MyString {
     *  // value does not have prefix `pre`
     *   string value = 1 [(buf.validate.field).string.prefix = "pre"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string prefix = 7 [json_name = "prefix", (.buf.validate.priv.field) = {</code>
     * @return string
     */
    public function getPrefix()
    {
        return isset($this->prefix) ? $this->prefix : '';
    }

    public function hasPrefix()
    {
        return isset($this->prefix);
    }

    public function clearPrefix()
    {
        unset($this->prefix);
    }

    /**
     *`prefix` specifies that the field value must have the
     *specified substring at the beginning of the string. If the field value
     *doesn't start with the specified prefix, an error message will be
     *generated.
     *```proto
     *message MyString {
     *  // value does not have prefix `pre`
     *   string value = 1 [(buf.validate.field).string.prefix = "pre"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string prefix = 7 [json_name = "prefix", (.buf.validate.priv.field) = {</code>
     * @param string $var
     * @return $this
     */
    public function setPrefix($var)
    {
        GPBUtil::checkString($var, True);
        $this->prefix = $var;

        return $this;
    }

    /**
     *`suffix` specifies that the field value must have the
     *specified substring at the end of the string. If the field value doesn't
     *end with the specified suffix, an error message will be generated.
     *```proto
     *message MyString {
     *  // value does not have suffix `post`
     *   string value = 1 [(buf.validate.field).string.suffix = "post"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string suffix = 8 [json_name = "suffix", (.buf.validate.priv.field) = {</code>
     * @return string
     */
    public function getSuffix()
    {
        return isset($this->suffix) ? $this->suffix : '';
    }

    public function hasSuffix()
    {
        return isset($this->suffix);
    }

    public function clearSuffix()
    {
        unset($this->suffix);
    }

    /**
     *`suffix` specifies that the field value must have the
     *specified substring at the end of the string. If the field value doesn't
     *end with the specified suffix, an error message will be generated.
     *```proto
     *message MyString {
     *  // value does not have suffix `post`
     *   string value = 1 [(buf.validate.field).string.suffix = "post"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string suffix = 8 [json_name = "suffix", (.buf.validate.priv.field) = {</code>
     * @param string $var
     * @return $this
     */
    public function setSuffix($var)
    {
        GPBUtil::checkString($var, True);
        $this->suffix = $var;

        return $this;
    }

    /**
     *`contains` specifies that the field value must have the
     *specified substring anywhere in the string. If the field value doesn't
     *contain the specified substring, an error message will be generated.
     *```proto
     *message MyString {
     *  // value does not contain substring `inside`.
     *   string value = 1 [(buf.validate.field).string.contains = "inside"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string contains = 9 [json_name = "contains", (.buf.validate.priv.field) = {</code>
     * @return string
     */
    public function getContains()
    {
        return isset($this->contains) ? $this->contains : '';
    }

    public function hasContains()
    {
        return isset($this->contains);
    }

    public function clearContains()
    {
        unset($this->contains);
    }

    /**
     *`contains` specifies that the field value must have the
     *specified substring anywhere in the string. If the field value doesn't
     *contain the specified substring, an error message will be generated.
     *```proto
     *message MyString {
     *  // value does not contain substring `inside`.
     *   string value = 1 [(buf.validate.field).string.contains = "inside"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string contains = 9 [json_name = "contains", (.buf.validate.priv.field) = {</code>
     * @param string $var
     * @return $this
     */
    public function setContains($var)
    {
        GPBUtil::checkString($var, True);
        $this->contains = $var;

        return $this;
    }

    /**
     *`not_contains` specifies that the field value must not have the
     *specified substring anywhere in the string. If the field value contains
     *the specified substring, an error message will be generated.
     *```proto
     *message MyString {
     *  // value contains substring `inside`.
     *   string value = 1 [(buf.validate.field).string.not_contains = "inside"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string not_contains = 23 [json_name = "notContains", (.buf.validate.priv.field) = {</code>
     * @return string
     */
    public function getNotContains()
    {
        return isset($this->not_contains) ? $this->not_contains : '';
    }

    public function hasNotContains()
    {
        return isset($this->not_contains);
    }

    public function clearNotContains()
    {
        unset($this->not_contains);
    }

    /**
     *`not_contains` specifies that the field value must not have the
     *specified substring anywhere in the string. If the field value contains
     *the specified substring, an error message will be generated.
     *```proto
     *message MyString {
     *  // value contains substring `inside`.
     *   string value = 1 [(buf.validate.field).string.not_contains = "inside"];
     *}
     *```
     *
     * Generated from protobuf field <code>optional string not_contains = 23 [json_name = "notContains", (.buf.validate.priv.field) = {</code>
     * @param string $var
     * @return $this
     */
    public function setNotContains($var)
    {
        GPBUtil::checkString($var, True);
        $this->not_contains = $var;

        return $this;
    }

    /**
     *`in` specifies that the field value must be equal to one of the specified
     *values. If the field value isn't one of the specified values, an error
     *message will be generated.
     *```proto
     *message MyString {
     *  // value must be in list ["apple", "banana"]
     *  repeated string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
     *}
     *```
     *
     * Generated from protobuf field <code>repeated string in = 10 [json_name = "in", (.buf.validate.priv.field) = {</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getIn()
    {
        return $this->in;
    }

    /**
     *`in` specifies that the field value must be equal to one of the specified
     *values. If the field value isn't one of the specified values, an error
     *message will be generated.
     *```proto
     *message MyString {
     *  // value must be in list ["apple", "banana"]
     *  repeated string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
     *}
     *```
     *
     * Generated from protobuf field <code>repeated string in = 10 [json_name = "in", (.buf.validate.priv.field) = {</code>
     * @param array<string>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setIn($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::STRING);
        $this->in = $arr;

        return $this;
    }

    /**
     *`not_in` specifies that the field value cannot be equal to any
     *of the specified values. If the field value is one of the specified values,
     *an error message will be generated.
     *```proto
     *message MyString {
     *  // value must not be in list ["orange", "grape"]
     *  repeated string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
     *}
     *```
     *
     * Generated from protobuf field <code>repeated string not_in = 11 [json_name = "notIn", (.buf.validate.priv.field) = {</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getNotIn()
    {
        return $this->not_in;
    }

    /**
     *`not_in` specifies that the field value cannot be equal to any
     *of the specified values. If the field value is one of the specified values,
     *an error message will be generated.
     *```proto
     *message MyString {
     *  // value must not be in list ["orange", "grape"]
     *  repeated string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
     *}
     *```
     *
     * Generated from protobuf field <code>repeated string not_in = 11 [json_name = "notIn", (.buf.validate.priv.field) = {</code>
     * @param array<string>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setNotIn($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::STRING);
        $this->not_in = $arr;

        return $this;
    }

    /**
     *`email` specifies that the field value must be a valid email address
     *(addr-spec only) as defined by [RFC 5322](https://tools.ietf.org/html/rfc5322#section-3.4.1).
     *If the field value isn't a valid email address, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid email address
     *   string value = 1 [(buf.validate.field).string.email = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool email = 12 [json_name = "email", (.buf.validate.priv.field) = {</code>
     * @return bool
     */
    public function getEmail()
    {
        return $this->readOneof(12);
    }

    public function hasEmail()
    {
        return $this->hasOneof(12);
    }

    /**
     *`email` specifies that the field value must be a valid email address
     *(addr-spec only) as defined by [RFC 5322](https://tools.ietf.org/html/rfc5322#section-3.4.1).
     *If the field value isn't a valid email address, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid email address
     *   string value = 1 [(buf.validate.field).string.email = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool email = 12 [json_name = "email", (.buf.validate.priv.field) = {</code>
     * @param bool $var
     * @return $this
     */
    public function setEmail($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(12, $var);

        return $this;
    }

    /**
     *`hostname` specifies that the field value must be a valid
     *hostname as defined by [RFC 1034](https://tools.ietf.org/html/rfc1034#section-3.5). This constraint doesn't support
     *internationalized domain names (IDNs). If the field value isn't a
     *valid hostname, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid hostname
     *   string value = 1 [(buf.validate.field).string.hostname = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool hostname = 13 [json_name = "hostname", (.buf.validate.priv.field) = {</code>
     * @return bool
     */
    public function getHostname()
    {
        return $this->readOneof(13);
    }

    public function hasHostname()
    {
        return $this->hasOneof(13);
    }

    /**
     *`hostname` specifies that the field value must be a valid
     *hostname as defined by [RFC 1034](https://tools.ietf.org/html/rfc1034#section-3.5). This constraint doesn't support
     *internationalized domain names (IDNs). If the field value isn't a
     *valid hostname, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid hostname
     *   string value = 1 [(buf.validate.field).string.hostname = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool hostname = 13 [json_name = "hostname", (.buf.validate.priv.field) = {</code>
     * @param bool $var
     * @return $this
     */
    public function setHostname($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(13, $var);

        return $this;
    }

    /**
     *`ip` specifies that the field value must be a valid IP
     *(v4 or v6) address, without surrounding square brackets for IPv6 addresses.
     *If the field value isn't a valid IP address, an error message will be
     *generated.
     *```proto
     *message MyString {
     *  // value must be a valid IP address
     *   string value = 1 [(buf.validate.field).string.ip = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool ip = 14 [json_name = "ip", (.buf.validate.priv.field) = {</code>
     * @return bool
     */
    public function getIp()
    {
        return $this->readOneof(14);
    }

    public function hasIp()
    {
        return $this->hasOneof(14);
    }

    /**
     *`ip` specifies that the field value must be a valid IP
     *(v4 or v6) address, without surrounding square brackets for IPv6 addresses.
     *If the field value isn't a valid IP address, an error message will be
     *generated.
     *```proto
     *message MyString {
     *  // value must be a valid IP address
     *   string value = 1 [(buf.validate.field).string.ip = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool ip = 14 [json_name = "ip", (.buf.validate.priv.field) = {</code>
     * @param bool $var
     * @return $this
     */
    public function setIp($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(14, $var);

        return $this;
    }

    /**
     *`ipv4` specifies that the field value must be a valid IPv4
     *address. If the field value isn't a valid IPv4 address, an error message
     *will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid IPv4 address
     *   string value = 1 [(buf.validate.field).string.ipv4 = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool ipv4 = 15 [json_name = "ipv4", (.buf.validate.priv.field) = {</code>
     * @return bool
     */
    public function getIpv4()
    {
        return $this->readOneof(15);
    }

    public function hasIpv4()
    {
        return $this->hasOneof(15);
    }

    /**
     *`ipv4` specifies that the field value must be a valid IPv4
     *address. If the field value isn't a valid IPv4 address, an error message
     *will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid IPv4 address
     *   string value = 1 [(buf.validate.field).string.ipv4 = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool ipv4 = 15 [json_name = "ipv4", (.buf.validate.priv.field) = {</code>
     * @param bool $var
     * @return $this
     */
    public function setIpv4($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(15, $var);

        return $this;
    }

    /**
     *`ipv6` specifies that the field value must be a valid
     *IPv6 address, without surrounding square brackets. If the field value is
     *not a valid IPv6 address, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid IPv6 address
     *   string value = 1 [(buf.validate.field).string.ipv6 = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool ipv6 = 16 [json_name = "ipv6", (.buf.validate.priv.field) = {</code>
     * @return bool
     */
    public function getIpv6()
    {
        return $this->readOneof(16);
    }

    public function hasIpv6()
    {
        return $this->hasOneof(16);
    }

    /**
     *`ipv6` specifies that the field value must be a valid
     *IPv6 address, without surrounding square brackets. If the field value is
     *not a valid IPv6 address, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid IPv6 address
     *   string value = 1 [(buf.validate.field).string.ipv6 = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool ipv6 = 16 [json_name = "ipv6", (.buf.validate.priv.field) = {</code>
     * @param bool $var
     * @return $this
     */
    public function setIpv6($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(16, $var);

        return $this;
    }

    /**
     *`uri` specifies that the field value must be a valid,
     *absolute URI as defined by [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3). If the field value isn't a valid,
     *absolute URI, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid URI
     *   string value = 1 [(buf.validate.field).string.uri = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool uri = 17 [json_name = "uri", (.buf.validate.priv.field) = {</code>
     * @return bool
     */
    public function getUri()
    {
        return $this->readOneof(17);
    }

    public function hasUri()
    {
        return $this->hasOneof(17);
    }

    /**
     *`uri` specifies that the field value must be a valid,
     *absolute URI as defined by [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3). If the field value isn't a valid,
     *absolute URI, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid URI
     *   string value = 1 [(buf.validate.field).string.uri = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool uri = 17 [json_name = "uri", (.buf.validate.priv.field) = {</code>
     * @param bool $var
     * @return $this
     */
    public function setUri($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(17, $var);

        return $this;
    }

    /**
     *`uri_ref` specifies that the field value must be a valid URI
     *as defined by [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) and may be either relative or absolute. If the
     *field value isn't a valid URI, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid URI
     *   string value = 1 [(buf.validate.field).string.uri_ref = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool uri_ref = 18 [json_name = "uriRef", (.buf.validate.priv.field) = {</code>
     * @return bool
     */
    public function getUriRef()
    {
        return $this->readOneof(18);
    }

    public function hasUriRef()
    {
        return $this->hasOneof(18);
    }

    /**
     *`uri_ref` specifies that the field value must be a valid URI
     *as defined by [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) and may be either relative or absolute. If the
     *field value isn't a valid URI, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid URI
     *   string value = 1 [(buf.validate.field).string.uri_ref = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool uri_ref = 18 [json_name = "uriRef", (.buf.validate.priv.field) = {</code>
     * @param bool $var
     * @return $this
     */
    public function setUriRef($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(18, $var);

        return $this;
    }

    /**
     *`address` specifies that the field value must be either a valid hostname
     *as defined by [RFC 1034](https://tools.ietf.org/html/rfc1034#section-3.5)
     *(which doesn't support internationalized domain names or IDNs) or a valid
     *IP (v4 or v6). If the field value isn't a valid hostname or IP, an error
     *message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid hostname, or ip address
     *   string value = 1 [(buf.validate.field).string.address = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool address = 21 [json_name = "address", (.buf.validate.priv.field) = {</code>
     * @return bool
     */
    public function getAddress()
    {
        return $this->readOneof(21);
    }

    public function hasAddress()
    {
        return $this->hasOneof(21);
    }

    /**
     *`address` specifies that the field value must be either a valid hostname
     *as defined by [RFC 1034](https://tools.ietf.org/html/rfc1034#section-3.5)
     *(which doesn't support internationalized domain names or IDNs) or a valid
     *IP (v4 or v6). If the field value isn't a valid hostname or IP, an error
     *message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid hostname, or ip address
     *   string value = 1 [(buf.validate.field).string.address = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool address = 21 [json_name = "address", (.buf.validate.priv.field) = {</code>
     * @param bool $var
     * @return $this
     */
    public function setAddress($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(21, $var);

        return $this;
    }

    /**
     *`uuid` specifies that the field value must be a valid UUID as defined by
     *[RFC 4122](https://tools.ietf.org/html/rfc4122#section-4.1.2). If the
     *field value isn't a valid UUID, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid UUID
     *   string value = 1 [(buf.validate.field).string.uuid = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool uuid = 22 [json_name = "uuid", (.buf.validate.priv.field) = {</code>
     * @return bool
     */
    public function getUuid()
    {
        return $this->readOneof(22);
    }

    public function hasUuid()
    {
        return $this->hasOneof(22);
    }

    /**
     *`uuid` specifies that the field value must be a valid UUID as defined by
     *[RFC 4122](https://tools.ietf.org/html/rfc4122#section-4.1.2). If the
     *field value isn't a valid UUID, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid UUID
     *   string value = 1 [(buf.validate.field).string.uuid = true];
     *}
     *```
     *
     * Generated from protobuf field <code>bool uuid = 22 [json_name = "uuid", (.buf.validate.priv.field) = {</code>
     * @param bool $var
     * @return $this
     */
    public function setUuid($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(22, $var);

        return $this;
    }

    /**
     *`well_known_regex` specifies a common well-known pattern
     *defined as a regex. If the field value doesn't match the well-known
     *regex, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid HTTP header value
     *   string value = 1 [(buf.validate.field).string.well_known_regex = 2];
     *}
     *```
     *#### KnownRegex
     *`well_known_regex` contains some well-known patterns.
     *| Name                          | Number | Description                               |
     *|-------------------------------|--------|-------------------------------------------|
     *| KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |
     *| KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2)  |
     *| KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2.4) |
     *
     * Generated from protobuf field <code>.buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.priv.field) = {</code>
     * @return int
     */
    public function getWellKnownRegex()
    {
        return $this->readOneof(24);
    }

    public function hasWellKnownRegex()
    {
        return $this->hasOneof(24);
    }

    /**
     *`well_known_regex` specifies a common well-known pattern
     *defined as a regex. If the field value doesn't match the well-known
     *regex, an error message will be generated.
     *```proto
     *message MyString {
     *  // value must be a valid HTTP header value
     *   string value = 1 [(buf.validate.field).string.well_known_regex = 2];
     *}
     *```
     *#### KnownRegex
     *`well_known_regex` contains some well-known patterns.
     *| Name                          | Number | Description                               |
     *|-------------------------------|--------|-------------------------------------------|
     *| KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |
     *| KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2)  |
     *| KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2.4) |
     *
     * Generated from protobuf field <code>.buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.priv.field) = {</code>
     * @param int $var
     * @return $this
     */
    public function setWellKnownRegex($var)
    {
        GPBUtil::checkEnum($var, \Buf\Validate\KnownRegex::class);
        $this->writeOneof(24, $var);

        return $this;
    }

    /**
     *This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
     *enable strict header validation. By default, this is true, and HTTP header
     *validations are [RFC-compliant](https://tools.ietf.org/html/rfc7230#section-3). Setting to false will enable looser
     *validations that only disallow `\r\n\0` characters, which can be used to
     *bypass header matching rules.
     *```proto
     *message MyString {
     *   // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
     *   string value = 1 [(buf.validate.field).string.strict = false];
     *}
     *```
     *
     * Generated from protobuf field <code>optional bool strict = 25 [json_name = "strict"];</code>
     * @return bool
     */
    public function getStrict()
    {
        return isset($this->strict) ? $this->strict : false;
    }

    public function hasStrict()
    {
        return isset($this->strict);
    }

    public function clearStrict()
    {
        unset($this->strict);
    }

    /**
     *This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
     *enable strict header validation. By default, this is true, and HTTP header
     *validations are [RFC-compliant](https://tools.ietf.org/html/rfc7230#section-3). Setting to false will enable looser
     *validations that only disallow `\r\n\0` characters, which can be used to
     *bypass header matching rules.
     *```proto
     *message MyString {
     *   // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
     *   string value = 1 [(buf.validate.field).string.strict = false];
     *}
     *```
     *
     * Generated from protobuf field <code>optional bool strict = 25 [json_name = "strict"];</code>
     * @param bool $var
     * @return $this
     */
    public function setStrict($var)
    {
        GPBUtil::checkBool($var);
        $this->strict = $var;

        return $this;
    }

    /**
     * @return string
     */
    public function getWellKnown()
    {
        return $this->whichOneof("well_known");
    }

}

